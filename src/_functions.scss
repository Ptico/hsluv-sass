@import "node_modules/mathsass/dist/math";
@import "node_modules/mathsass/dist/constants";

@import "utils/dec-to-hex";
@import "utils/hex-to-dec";
@import "utils/parse-int";

// @typedef {number[2]} Line
// @typedef {number[2]} Point
// @typedef {number[][2]} Lightness
// @typedef {number[3]} Tuple

$m: (
  r: (  3.2409699419045214,   -1.5373831775700935, -0.49861076029300328  ),
  g: ( -0.96924363628087983,   1.8759675015077207,  0.041555057407175613 ),
  b: (  0.055630079696993609, -0.20397695888897657, 1.0569715142428786   )
);
$m-inv: (
  x: ( 0.41239079926595948,  0.35758433938387796, 0.18048078840183429  ),
  y: ( 0.21263900587151036,  0.71516867876775593, 0.072192315360733715 ),
  z: ( 0.019330818715591851, 0.11919477979462599, 0.95053215224966058  )
);

$ref-u: 0.19783000664283681;
$ref-v: 0.468319994938791;

// CIE LUV constants
$kappa: 903.2962962962963;
$epsilon: 0.0088564516790356308;

// For a given lightness, return a list of 6 lines in slope-intercept
// form that represent the bounds in CIELUV, stepping over which will
// push a value out of the RGB gamut
// @param {number} $l
// @return {number[][2]}
@function get-bounds($l) {
  $sub1: pow($l + 16, 3) / 1560896;
  $sub2: if($sub1 > $epsilon, $sub1, $l / $kappa);
  $ret: ();
  @each $channel in (r, g, b) {
    $m_: map-get($m, $channel);
    $m1: nth($m_, 1);
    $m2: nth($m_, 2);
    $m3: nth($m_, 3);
    @for $t from 0 through 1 {
      $top1: (284517 * $m1 - 94839 * $m3) * $sub2;
      $top2: (838422 * $m3 + 769860 * $m2 + 731718 * $m1) * $l * $sub2 - 769860 * $t * $l;
      $bottom: (632260 * $m3 - 126452 * $m2) * $sub2 + 126452 * $t;

      $ret: append($ret, ($top1 / $bottom, $top2 / $bottom));
    }
  }

  @return $ret;
}

// @param {number[2]} $line1
// @param {number[2]} $line2
// @return {number}
@function intersect-line-line($line1, $line2) {
  @return (nth($line1, 2) - nth($line2, 2)) / (nth($line2, 1) - nth($line1, 1));
}

// @param {number[2]} $point
// @return {number}
@function distance-from-pole($point) {
  @return sqrt(pow(nth($point, 1), 2) + pow(nth($point, 2), 2));
}

// @param {number} $theta
// @param {number[2]} $line
// @return {number?}
@function length-of-ray-until-intersect($theta, $line) {
  // theta  -- angle of ray starting at (0, 0)
  // m, b   -- slope and intercept of line
  // x1, y1 -- coordinates of intersection
  // len    -- length of ray until it intersects with line
  //
  // b + m * x1        = y1
  // len              >= 0
  // len * cos(theta)  = x1
  // len * sin(theta)  = y1
  //
  //
  // b + m * (len * cos(theta)) = len * sin(theta)
  // b = len * sin(hrad) - m * len * cos(theta)
  // b = len * (sin(hrad) - m * cos(hrad))
  // len = b / (sin(hrad) - m * cos(hrad))

  $m1: nth($line, 1);
  $b1: nth($line, 2);
  $len: $b1 / (sin($theta) - $m1 * cos($theta));
  @return if($len < 0, null, $len);
}

// For given lightness, returns the maximum chroma. Keeping the chroma value
// below this number will ensure that for any hue, the color is within the RGB
// gamut.
// @param {number[][2]} $l
// @return {number}
@function max-safe-chroma-for-l($l) {
  $lengths: ();

  @each $point in get-bounds($l) {
    $m1: nth($point, 1);
    $b1: nth($point, 2);
    // x where line intersects with perpendicular running though (0, 0)
    $x: intersect-line-line(($m1, $b1), (-1 / $m1, 0));
    $lengths: append($lengths, distance-from-pole(($x, $b1 + $x * $m1)));
  }

  @return min($lengths...);
}

// For a given lightness and hue, return the maximum chroma that fits in
// the RGB gamut.
// @param {number[][2]} $l
// @param {number} $h
// @return {number}
@function max-chroma-for-l-h($l, $h) {
  $hrad: $h / 360 * $PI * 2;
  $lengths: ();

  @each $line in get-bounds($l) {
    $l: length-of-ray-until-intersect($hrad, $line);
    @if $l != null {
      $lengths: append($lengths, $l);
    }
  }

  @return min($lengths...);
}

// @param {number[]} $a
// @param {number[]} $b
// @return {number}
@function dot-product($a, $b) {
  $ret: 0;
  @for $i from 1 through length($a) {
    $ret: $ret + nth($a, $i) * nth($b, $i);
  }
  @return $ret;
}

// Used for rgb conversions
// @param {number} $c
// @return {number}
@function from-linear($c) {
  @return if($c <= 0.0031308, 12.92 * $c, 1.055 * pow($c, 1 / 2.4) - 0.055);
}

// @param {number} $c
// @return {number}
@function to-linear($c) {
  $a: 0.055;
  @if $c > 0.04045 {
    @return pow(($c + $a) / (1 + $a), 2.4);
  } @else {
    @return $c / 12.92;
  }
}

//// Color format conversions

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-xyz-rgb($tuple) {
  $r: from-linear(dot-product(map-get($m, r), $tuple));
  $g: from-linear(dot-product(map-get($m, g), $tuple));
  $b: from-linear(dot-product(map-get($m, b), $tuple));
  @return ($r, $g, $b);
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-rgb-xyz($tuple) {
  $r: nth($tuple, 1);
  $g: nth($tuple, 2);
  $b: nth($tuple, 3);
  $rgbl: (to-linear($r), to-linear($g), to-linear($b));
  $x: dot-product(map-get($m_inv, x), $rgbl);
  $y: dot-product(map-get($m_inv, y), $rgbl);
  $z: dot-product(map-get($m_inv, z), $rgbl);
  @return ($x, $y, $z);
}

// http://en.wikipedia.org/wiki/CIELUV
// In these formulas, Yn refers to the reference white point. We are using
// illuminant D65, so Yn (see refY in Maxima file) equals 1. The formula is
// simplified accordingly.
// @param {number} $y
// @return {number}
@function y-to-l($y) {
  @if $y <= $epsilon {
    @return $y * $kappa;
  } @else {
    @return 116 * pow($y, 1/3) - 16;
  }
}

// @param {number} $l
// @return {number}
@function l-to-y($l) {
  @if $l <= 8 {
    @return $l / $kappa;
  } @else {
    @return pow(($l + 16) / 116, 3);
  }
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-xyz-luv($tuple) {
  $x: nth($tuple, 1);
  $y: nth($tuple, 2);
  $z: nth($tuple, 3);
  // black will create a divide-by-zero error in
  // the following two lines
  @if $y == 0 {
    @return (0, 0, 0);
  }
  $l: y-to-l($y);
  $var-u: (4 * $x) / ($x + (15 * $y) + (3 * $z));
  $var-v: (9 * $y) / ($x + (15 * $y) + (3 * $z));
  $u: 13 * $l * ($var-u - $ref-u);
  $v: 13 * $l * ($var-v - $ref-v);
  @return ($l, $u, $v);
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-luv-xyz($tuple) {
  $l: nth($tuple, 1);
  $u: nth($tuple, 2);
  $v: nth($tuple, 3);
  // black will create a divide-by-zero error
  @if $l == 0 {
    @return (0, 0, 0);
  }
  $var-u: $u / (13 * $l) + $ref-u;
  $var-v: $v / (13 * $l) + $ref-v;
  $y: l-to-y($l);
  $x: 0 - (9 * $y * $var-u) / (($var-u - 4) * $var-v - $var-u * $var-v);
  $z: (9 * $y - (15 * $var-v * $y) - ($var-v * $x)) / (3 * $var-v);
  @return ($x, $y, $z);
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-luv-lch($tuple) {
  $l: nth($tuple, 1);
  $u: nth($tuple, 2);
  $v: nth($tuple, 3);
  $c: sqrt(pow($u, 2) + pow($v, 2));
  $h: 0;
  // greys: disambiguate hue
  @if $c >= 0.00000001 {
    $h-rad: atan2($v, $u);
    $h: $h-rad * 360 / 2 / $PI;
    @if $h < 0 {
      $h: 360 + $h;
    }
  }
  @return ($l, $c, $h);
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-lch-luv($tuple) {
  $l: nth($tuple, 1);
  $c: nth($tuple, 2);
  $h: nth($tuple, 3);
  $h-rad: $h / 360 * 2 * $PI;
  $u: cos($h-rad) * $c;
  $v: sin($h-rad) * $c;
  @return ($l, $u, $v);
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-husl-lch($tuple) {
  $h: nth($tuple, 1);
  $s: nth($tuple, 2);
  $l: nth($tuple, 3);
  $c: 0;
  // white and black: disambiguate chroma
  @if not ($l > 99.9999999 or $l < 0.00000001) {
    $max: max-chroma-for-l-h($l, $h);
    $c: $max / 100 * $s;
  }
  @return ($l, $c, $h);
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-lch-husl($tuple) {
  $l: nth($tuple, 1);
  $c: nth($tuple, 2);
  $h: nth($tuple, 3);
  $s: 0;
  // white and black: disambiguate saturation
  @if not ($l > 99.9999999 or $l < 0.00000001) {
    $max: max-chroma-for-l-h($l, $h);
    $s: $c / $max * 100;
  }
  @return ($h, $s, $l);
}

//// PASTEL HUSL

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-huslp-lch($tuple) {
  $h: nth($tuple, 1);
  $s: nth($tuple, 2);
  $l: nth($tuple, 3);
  $c: 0;
  // white and black: disambiguate chroma
  @if not ($l > 99.9999999 or $l < 0.00000001) {
    $max: max-safe-chroma-for-l($l);
    $c: $max / 100 * $s;
  }
  @return ($l, $c, $h);
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-lch-huslp($tuple) {
  $l: nth($tuple, 1);
  $c: nth($tuple, 2);
  $h: nth($tuple, 3);
  $s: 0;
  // White and black: disambiguate saturation
  @if not ($l > 99.9999999 or $l < 0.00000001) {
    $max: max-safe-chroma-for-l($l);
    $s: $c / $max * 100;
  }
  @return ($h, $s, $l);
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-rgb-hex($tuple) {
  $hex: "#";
  @each $ch in $tuple {
    // Round to 6 decimal places
    $ch: round($ch * 1000000) / 1000000;
    @if $ch < 0 or $ch > 1 {
      @error "Illegal rgb value: #{$ch} from #{$tuple}";
    }
    $ch: dec-to-hex(round($ch * 255));
    @if length($ch) == 1 {
      $ch: "0" + inspect($ch);
    }
    $hex: $hex + $ch;
  }
  @return $hex;
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-hex-rgb($hex) {
  @if str-slice($hex, 1, 1) == "#" {
    $hex: str-slice($hex, 2, 8);
  }
  // TODO
  $r: hex-to-dec(str-slice($hex, 1, 3)) / 255;
  $g: hex-to-dec(str-slice($hex, 3, 5)) / 255;
  $b: hex-to-dec(str-slice($hex, 5, 7)) / 255;
  @return ($r, $g, $b);
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-lch-rgb($tuple) {
  @return conv-xyz-rgb(conv-luv-xyz(conv-lch-luv($tuple)));
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-rgb-lch($tuple) {
  @return conv-luv-lch(conv-xyz-luv(conv-rgb-xyz($tuple)));
}

// @param {Tuple} $tuple
// @return {Tuple}
@function conv-husl-rgb($tuple) {
  @return conv-lch-rgb(conv-husl-lch($tuple));
}
// @param {Tuple} $tuple
// @return {Tuple}
@function conv-rgb-husl($tuple) {
  @return conv-lch-husl(conv-rgb-lch($tuple));
}
// @param {Tuple} $tuple
// @return {Tuple}
@function conv-huslp-rgb($tuple) {
  @return conv-lch-rgb(conv-huslp-lch($tuple));
}
// @param {Tuple} $tuple
// @return {Tuple}
@function conv-rgb-huslp($tuple) {
  @return conv-lch-huslp(conv-rgb-lch($tuple));
}
